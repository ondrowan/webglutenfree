function never(e,r){throw new Error(fmt(r||`Unexpected object: ${e}`))}function fmt(e){return e?`Assertion Failed: ${e}`:"Assertion Failed"}function createProgram(e,r,t){const n=e.createProgram();if(!n)throw new Error("Could not create Program");if(e.attachShader(n,r),e.attachShader(n,t),e.linkProgram(n),e.getProgramParameter(n,e.LINK_STATUS))return n;const a=e.getProgramInfoLog(n);throw e.deleteProgram(n),new Error(`Could not link shader program: ${a}`)}function createShader(e,r,t){const n=e.createShader(r);if(!n)throw new Error("Could not create Shader");if(e.shaderSource(n,t),e.compileShader(n),e.getShaderParameter(n,e.COMPILE_STATUS))return n;const a=e.getShaderInfoLog(n);e.deleteShader(n);const i=t.split("\n").map((e,r)=>`${r+1}: ${e}`).join("\n");throw new Error(`Could not compile shader:\n${a}\n${i}`)}function is2DArray(e){return!!e.length||Array.isArray(e[0])}function ravel(e){const r=e.length,t=r?e[0].length:0,n=new Array(t*r);return e.forEach((e,r)=>{e.forEach((e,a)=>{n[t*r+a]=e})}),{data:n,shape:[r,t]}}function mapGlVertexBufferType(e,r){switch(r){case"byte":return e.BYTE;case"short":return e.SHORT;case"int":return e.INT;case"unsigned byte":return e.UNSIGNED_BYTE;case"unsigned short":return e.UNSIGNED_SHORT;case"unsigned int":return e.UNSIGNED_INT;case"float":return e.FLOAT;default:return never(r,`Unexpexted buffer type: ${r}`)}}function locate(e,r,{attributes:t,elements:n}){return{attributes:Object.entries(t).reduce((t,[n,a])=>{if(INT_PATTERN.test(n))t[n]=a;else{const i=e.getAttribLocation(r,n);if(i===UNKNOWN_ATTRIB_LOCATION)throw new Error(`No location for attrib: ${n}`);t[i]=a}return t},{}),elements:n}}function access(e,r,t){return"function"==typeof t?t(e,r):t}function mapGlPrimitive(e,r){switch(r){case"triangles":return e.TRIANGLES;case"triangle-strip":return e.TRIANGLE_STRIP;case"triangle-fan":return e.TRIANGLE_FAN;case"points":return e.POINTS;case"lines":return e.LINES;case"line-strip":return e.LINE_STRIP;case"line-loop":return e.LINE_LOOP;default:return never(r,`Unknown primitive: ${r}`)}}function mapGlDepthOrStencilFunc(e,r){switch(r){case"always":return e.ALWAYS;case"never":return e.NEVER;case"equal":return e.EQUAL;case"notequal":return e.NOTEQUAL;case"less":return e.LESS;case"lequal":return e.LEQUAL;case"greater":return e.GREATER;case"gequal":return e.GEQUAL;default:return never(r,`Unknown depth or stencil function: ${r}`)}}function mapGlStencilOp(e,r){switch(r){case"keep":return e.KEEP;case"zero":return e.ZERO;case"replace":return e.REPLACE;case"incr":return e.INCR;case"incr-wrap":return e.INCR_WRAP;case"decr":return e.DECR;case"decr-wrap":return e.DECR_WRAP;case"invert":return e.INVERT;default:return never(r,`Unknown stencil op: ${r}`)}}function mapGlBlendFunc(e,r){switch(r){case"zero":return e.ZERO;case"one":return e.ONE;case"src-color":return e.SRC_COLOR;case"src-alpha":return e.SRC_ALPHA;case"one-minus-src-color":return e.ONE_MINUS_SRC_COLOR;case"one-minus-src-alpha":return e.ONE_MINUS_SRC_ALPHA;case"dst-color":return e.DST_COLOR;case"dst-alpha":return e.DST_ALPHA;case"one-minus-dst-color":return e.ONE_MINUS_DST_COLOR;case"one-minus-dst-alpha":return e.ONE_MINUS_DST_ALPHA;case"constant-color":return e.CONSTANT_COLOR;case"constant-alpha":return e.CONSTANT_ALPHA;case"one-minus-constant-color":return e.ONE_MINUS_CONSTANT_COLOR;case"one-minus-constant-alpha":return e.ONE_MINUS_CONSTANT_ALPHA;default:return never(r,`Unknown blend func: ${r}`)}}function mapGlBlendEquation(e,r){switch(r){case"add":return e.FUNC_ADD;case"subtract":return e.FUNC_SUBTRACT;case"reverse-subtract":return e.FUNC_REVERSE_SUBTRACT;case"min":return e.MIN;case"max":return e.MAX;default:return never(r,`Unknown blend equation, ${r}`)}}function parseDepth(e,r){if(r)return new DepthDescriptor(mapGlDepthOrStencilFunc(e,r.func||"less"),"boolean"!=typeof r.mask||r.mask,r.range?r.range[0]:0,r.range?r.range[1]:1)}function parseStencil(e,r){if(r)return new StencilDescriptor(mapGlDepthOrStencilFunc(e,"object"==typeof r.func.func?r.func.func.front:r.func.func),mapGlDepthOrStencilFunc(e,"object"==typeof r.func.func?r.func.func.back:r.func.func),void 0!==r.func.ref?"object"==typeof r.func.ref?r.func.ref.front:r.func.ref:1,void 0!==r.func.ref?"object"==typeof r.func.ref?r.func.ref.back:r.func.ref:1,void 0!==r.func.mask?"object"==typeof r.func.mask?r.func.mask.front:r.func.mask:255,void 0!==r.func.mask?"object"==typeof r.func.mask?r.func.mask.back:r.func.mask:255,void 0!==r.mask?"object"==typeof r.mask?r.mask.front:r.mask:255,void 0!==r.mask?"object"==typeof r.mask?r.mask.back:r.mask:255,mapGlStencilOp(e,r.op?"object"==typeof r.op.fail?r.op.fail.front:r.op.fail:"keep"),mapGlStencilOp(e,r.op?"object"==typeof r.op.fail?r.op.fail.back:r.op.fail:"keep"),mapGlStencilOp(e,r.op?"object"==typeof r.op.zfail?r.op.zfail.front:r.op.zfail:"keep"),mapGlStencilOp(e,r.op?"object"==typeof r.op.zfail?r.op.zfail.back:r.op.zfail:"keep"),mapGlStencilOp(e,r.op?"object"==typeof r.op.zpass?r.op.zpass.front:r.op.zpass:"keep"),mapGlStencilOp(e,r.op?"object"==typeof r.op.zpass?r.op.zpass.back:r.op.zpass:"keep"))}function parseBlend(e,r){if(r)return new BlendDescriptor(mapGlBlendFunc(e,"object"==typeof r.func.src?r.func.src.rgb:r.func.src),mapGlBlendFunc(e,"object"==typeof r.func.src?r.func.src.alpha:r.func.src),mapGlBlendFunc(e,"object"==typeof r.func.dst?r.func.dst.rgb:r.func.dst),mapGlBlendFunc(e,"object"==typeof r.func.dst?r.func.dst.alpha:r.func.dst),mapGlBlendEquation(e,r.equation?"object"==typeof r.equation?r.equation.rgb:r.equation:"add"),mapGlBlendEquation(e,r.equation?"object"==typeof r.equation?r.equation.alpha:r.equation:"add"),r.color)}function mapGlTextureWrap(e,r){switch(r){case"clamp-to-edge":return e.CLAMP_TO_EDGE;case"repeat":return e.REPEAT;case"mirrored-repeat":return e.MIRRORED_REPEAT;default:return never(r,`Unknown texture wrap: ${r}`)}}function mapGlTextureFilter(e,r){switch(r){case"nearest":return e.NEAREST;case"linear":return e.LINEAR;case"nearest-mipmap-nearest":return e.NEAREST_MIPMAP_NEAREST;case"linear-mipmap-nearest":return e.LINEAR_MIPMAP_NEAREST;case"nearest-mipmap-linear":return e.NEAREST_MIPMAP_LINEAR;case"linear-mipmap-linear":return e.LINEAR_MIPMAP_LINEAR;default:return never(r,`Unknown texture filter: ${r}`)}}function mapGlTextureInternalFormat(e,r){switch(r){case"R8":return e.R8;case"R8_SNORM":return e.R8_SNORM;case"R8UI":return e.R8UI;case"R8I":return e.R8I;case"R16UI":return e.R16UI;case"R16I":return e.R16I;case"R32UI":return e.R32UI;case"R32I":return e.R32I;case"R16F":return e.R16I;case"R32F":return e.R32F;case"RG8":return e.RG8;case"RG8_SNORM":return e.RG8_SNORM;case"RG8UI":return e.RG8UI;case"RG8I":return e.RG8I;case"RG16UI":return e.RG16UI;case"RG16I":return e.RG16I;case"RG32UI":return e.RG32UI;case"RG32I":return e.RG32I;case"RG16F":return e.RG16F;case"RG32F":return e.RG32F;case"RGB8":return e.RGB8;case"RGB8_SNORM":return e.RGB8_SNORM;case"RGB8UI":return e.RGB8UI;case"RGB8I":return e.RGB8I;case"RGB16UI":return e.RGB16UI;case"RGB16I":return e.RGB16I;case"RGB32UI":return e.RGB32UI;case"RGB32I":return e.RGB32I;case"RGB16F":return e.RGB16F;case"RGB32F":return e.RGB32F;case"RGBA8":return e.RGBA8;case"RGBA8_SNORM":return e.RGBA8_SNORM;case"RGBA8UI":return e.RGBA8UI;case"RGBA8I":return e.RGBA8I;case"RGBA16UI":return e.RGBA16UI;case"RGBA16I":return e.RGBA16I;case"RGBA32UI":return e.RGBA32UI;case"RGBA32I":return e.RGBA32I;case"RGBA16F":return e.RGBA16F;case"RGBA32F":return e.RGBA32F;default:return never(r,`Unknown texture internal format: ${r}`)}}function mapGlTextureFormat(e,r){switch(r){case"RED":return e.RED;case"RG":return e.RG;case"RGB":return e.RGB;case"RGBA":return e.RGBA;case"RED_INTEGER":return e.RED_INTEGER;case"RG_INTEGER":return e.RG_INTEGER;case"RGB_INTEGER":return e.RGB_INTEGER;case"RGBA_INTEGER":return e.RGBA_INTEGER;default:return never(r,`Unknown texture format: ${r}`)}}function mapGlTextureType(e,r){switch(r){case"byte":return e.BYTE;case"short":return e.SHORT;case"int":return e.INT;case"unsigned byte":return e.UNSIGNED_BYTE;case"unsigned short":return e.UNSIGNED_SHORT;case"unsigned int":return e.UNSIGNED_INT;case"float":return e.FLOAT;default:return never(r,`Unknown texture type: ${r}`)}}class Device{constructor(e,r,t,n){this.gl=e,this.canvas=r,this.explicitPixelRatio=t,this.explicitViewport=n}static mount(e=document.body,r){if(e instanceof HTMLCanvasElement)return Device.fromCanvas(e,r);const t=document.createElement("canvas");return e.appendChild(t),Device.fromCanvas(t,r)}static fromCanvas(e,r={}){const{antialias:t=!0,alpha:n=!0,depth:a=!0,stencil:i=!0,preserveDrawingBuffer:s=!1}=r.context||{},c=e.getContext("webgl2",{antialias:t,alpha:n,depth:a,stencil:i,preserveDrawingBuffer:s});if(!c)throw new Error("Could not get webgl2 context");return Device.fromContext(c,r)}static fromContext(e,{pixelRatio:r,viewport:t,extensions:n}={}){n&&n.forEach(r=>{if(!e.getExtension(r))throw new Error(`Could not get extension ${r}`)});const a=new Device(e,e.canvas,r,t);return a.update(),a}get bufferWidth(){return this.gl.drawingBufferWidth}get bufferHeight(){return this.gl.drawingBufferHeight}get canvasWidth(){return this.canvas.width}get canvasHeight(){return this.canvas.height}get canvasCSSWidth(){return this.canvas.clientWidth}get canvasCSSHeight(){return this.canvas.clientHeight}get pixelRatio(){return this.explicitPixelRatio||window.devicePixelRatio}update(){const e=this.pixelRatio,r=this.canvas,t=this.explicitViewport&&this.explicitViewport[0]||r.clientWidth*e,n=this.explicitViewport&&this.explicitViewport[1]||r.clientHeight*e;t!==r.width&&(r.width=t),n!==r.height&&(r.height=n)}clearColorBuffer(e,r,t,n,a){const i=this.gl;a&&i.bindFramebuffer(i.FRAMEBUFFER,a.glFramebuffer),i.clearColor(e,r,t,n),i.clear(i.COLOR_BUFFER_BIT),a&&i.bindFramebuffer(i.FRAMEBUFFER,null)}clearDepthBuffer(e,r){const t=this.gl;r&&t.bindFramebuffer(t.FRAMEBUFFER,r.glFramebuffer),t.clearDepth(e),t.clear(t.DEPTH_BUFFER_BIT),r&&t.bindFramebuffer(t.FRAMEBUFFER,null)}clearStencilBuffer(e,r){const t=this.gl;r&&t.bindFramebuffer(t.FRAMEBUFFER,r.glFramebuffer),t.clearStencil(e),t.clear(t.STENCIL_BUFFER_BIT),r&&t.bindFramebuffer(t.FRAMEBUFFER,null)}clearColorAndDepthBuffers(e,r,t,n,a,i){const s=this.gl;i&&s.bindFramebuffer(s.FRAMEBUFFER,i.glFramebuffer),s.clearColor(e,r,t,n),s.clearDepth(a),s.clear(s.COLOR_BUFFER_BIT|s.DEPTH_BUFFER_BIT),i&&s.bindFramebuffer(s.FRAMEBUFFER,null)}clearDepthAndStencilBuffers(e,r,t){const n=this.gl;t&&n.bindFramebuffer(n.FRAMEBUFFER,t.glFramebuffer),n.clearDepth(e),n.clearStencil(r),n.clear(n.DEPTH_BUFFER_BIT|n.STENCIL_BUFFER_BIT),t&&n.bindFramebuffer(n.FRAMEBUFFER,null)}clearColorAndStencilBuffers(e,r,t,n,a,i){const s=this.gl;i&&s.bindFramebuffer(s.FRAMEBUFFER,i.glFramebuffer),s.clearColor(e,r,t,n),s.clearStencil(a),s.clear(s.COLOR_BUFFER_BIT|s.STENCIL_BUFFER_BIT),i&&s.bindFramebuffer(s.FRAMEBUFFER,null)}clear(e,r,t,n,a,i,s){const c=this.gl;s&&c.bindFramebuffer(c.FRAMEBUFFER,s.glFramebuffer),c.clearColor(e,r,t,n),c.clearDepth(a),c.clearStencil(i),c.clear(c.COLOR_BUFFER_BIT|c.DEPTH_BUFFER_BIT|c.STENCIL_BUFFER_BIT),s&&c.bindFramebuffer(c.FRAMEBUFFER,null)}}class VertexBuffer{constructor(e,r,t){this.gl=e,this.type=r,this.data=t,this.glType=mapGlVertexBufferType(e,r),this.glBuffer=null,this.init()}static create(e,r){const t=e instanceof Device?e.gl:e;switch(r.type){case"byte":return VertexBuffer.fromInt8Array(t,r.data);case"short":return VertexBuffer.fromInt16Array(t,r.data);case"int":return VertexBuffer.fromInt32Array(t,r.data);case"unsigned byte":return VertexBuffer.fromUint8Array(t,r.data);case"unsigned short":return VertexBuffer.fromUint16Array(t,r.data);case"unsigned int":return VertexBuffer.fromUint32Array(t,r.data);case"float":return VertexBuffer.fromFloat32Array(t,r.data);default:return never(r)}}static fromInt8Array(e,r){const t=e instanceof Device?e.gl:e;return new VertexBuffer(t,"byte",r instanceof Int8Array?r:new Int8Array(r))}static fromInt16Array(e,r){const t=e instanceof Device?e.gl:e;return new VertexBuffer(t,"short",r instanceof Int16Array?r:new Int16Array(r))}static fromInt32Array(e,r){const t=e instanceof Device?e.gl:e;return new VertexBuffer(t,"int",r instanceof Int32Array?r:new Int32Array(r))}static fromUint8Array(e,r){const t=e instanceof Device?e.gl:e;return new VertexBuffer(t,"unsigned byte",r instanceof Uint8Array?r:new Uint8Array(r))}static fromUint16Array(e,r){const t=e instanceof Device?e.gl:e;return new VertexBuffer(t,"unsigned short",r instanceof Uint16Array?r:new Uint16Array(r))}static fromUint32Array(e,r){const t=e instanceof Device?e.gl:e;return new VertexBuffer(t,"unsigned int",r instanceof Uint32Array?r:new Uint32Array(r))}static fromFloat32Array(e,r){const t=e instanceof Device?e.gl:e;return new VertexBuffer(t,"float",r instanceof Float32Array?r:new Float32Array(r))}get count(){return this.data.length}init(){const{gl:e,data:r}=this,t=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,t),e.bufferData(e.ARRAY_BUFFER,r,e.STATIC_DRAW),e.bindBuffer(e.ARRAY_BUFFER,null),this.glBuffer=t}restore(){const{gl:e,glBuffer:r}=this;e.isBuffer(r)||this.init()}}class ElementBuffer{static create(e,r){return Array.isArray(r)?ElementBuffer.fromArray(e,r):ElementBuffer.fromUint32Array(e,r.data)}static fromArray(e,r){return ElementBuffer.fromUint32Array(e,is2DArray(r)?ravel(r).data:r)}static fromUint32Array(e,r){const t=e instanceof Device?e.gl:e,n=Array.isArray(r)?new Uint32Array(r):r;return new ElementBuffer(t,n)}constructor(e,r){this.gl=e,this.data=r,this.glBuffer=null,this.init()}get count(){return this.data.length}init(){const{gl:e,data:r}=this,t=e.createBuffer();e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,t),e.bufferData(e.ELEMENT_ARRAY_BUFFER,r,e.STATIC_DRAW),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null),this.glBuffer=t}restore(){const{gl:e,glBuffer:r}=this;e.isBuffer(r)||this.init()}}const INT_PATTERN$1=/^0|[1-9]\d*$/;class VertexArray{static create(e,{attributes:r,elements:t}){const n=e instanceof Device?e.gl:e,a=Object.entries(r).map(([e,r])=>{if(!INT_PATTERN$1.test(e))throw new Error("Location not a number. Use Command#locate");const t=parseInt(e,10);return AttributeDescriptor.create(n,t,r)}),i=t?t instanceof ElementBuffer?t:ElementBuffer.create(n,t):void 0,s=i?i.count:a.length?a.map(e=>e.count).reduce((e,r)=>Math.min(e,r)):0,c=a.filter(e=>!!e.divisor),u=c.length?c.map(e=>e.count*e.divisor).reduce((e,r)=>Math.min(e,r)):0;return new VertexArray(n,a,i,s,u)}constructor(e,r,t,n,a){this.gl=e,this.elementBuffer=t,this.attributes=r,this.count=n,this.instanceCount=a,this.glVertexArray=null,this.init()}get hasElements(){return!!this.elementBuffer}init(){const{gl:e,attributes:r,elementBuffer:t}=this;if(!e.isContextLost()){const n=e.createVertexArray();e.bindVertexArray(n),r.forEach(({location:r,type:t,buffer:{glBuffer:n,glType:a},size:i,normalized:s=!1,divisor:c})=>{switch(e.enableVertexAttribArray(r),e.bindBuffer(e.ARRAY_BUFFER,n),t){case"pointer":e.vertexAttribPointer(r,i,a,s,0,0);break;case"ipointer":e.vertexAttribIPointer(r,i,a,0,0);break;default:never(t)}c&&e.vertexAttribDivisor(r,c)}),t&&e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,t.glBuffer),e.bindVertexArray(null),e.bindBuffer(e.ARRAY_BUFFER,null),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null),this.glVertexArray=n}}restore(){const{gl:e,glVertexArray:r,attributes:t,elementBuffer:n}=this;n&&n.restore(),t.forEach(e=>e.buffer.restore()),e.isVertexArray(r)||this.init()}}class AttributeDescriptor{constructor(e,r,t,n,a,i,s){this.location=e,this.type=r,this.buffer=t,this.count=n,this.size=a,this.normalized=i,this.divisor=s}static create(e,r,t){if(Array.isArray(t)){if(is2DArray(t)){const n=ravel(t);return new AttributeDescriptor(r,"pointer",VertexBuffer.fromFloat32Array(e,n.data),n.shape[0],n.shape[1],!1,0)}return new AttributeDescriptor(r,"pointer",VertexBuffer.fromFloat32Array(e,t),t.length,1,!1,0)}const n=t.value instanceof VertexBuffer?t.value:VertexBuffer.create(e,t.value);switch(t.type){case"pointer":return new AttributeDescriptor(r,t.type,n,t.count,t.size,t.normalized||!1,t.divisor||0);case"ipointer":return new AttributeDescriptor(r,t.type,n,t.count,t.size,!1,t.divisor||0);default:return never(t)}}}class Framebuffer{static create(e,{width:r,height:t,color:n,depth:a,stencil:i}){const s=e instanceof Device?e.gl:e,c=Array.isArray(n)?n:[n];return c.forEach(e=>{}),new Framebuffer(s,r,t,c,a,i)}constructor(e,r,t,n,a,i){this.gl=e,this.width=r,this.height=t,this.colorBuffers=n,this.depthBuffer=a,this.stencilBuffer=i,this.glColorAttachments=n.map((r,t)=>e.COLOR_ATTACHMENT0+t),this.glFramebuffer=null,this.init()}init(){const{gl:e,colorBuffers:r,depthBuffer:t,stencilBuffer:n}=this,a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),r.forEach((r,t)=>{e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0+t,e.TEXTURE_2D,r.glTexture,0)}),t&&e.framebufferTexture2D(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.TEXTURE_2D,t,0),n&&e.framebufferTexture2D(e.FRAMEBUFFER,e.STENCIL_ATTACHMENT,e.TEXTURE_2D,n,0);const i=e.checkFramebufferStatus(e.FRAMEBUFFER);if(e.bindFramebuffer(e.FRAMEBUFFER,null),i!==e.FRAMEBUFFER_COMPLETE)throw e.deleteFramebuffer(a),new Error("Framebuffer not complete");this.glFramebuffer=a}restore(){const{gl:e,glFramebuffer:r,colorBuffers:t,depthBuffer:n,stencilBuffer:a}=this;t.forEach(e=>e.restore()),n&&n.restore(),a&&a.restore(),e.isFramebuffer(r)||this.init()}}const INT_PATTERN=/^0|[1-9]\d*$/,UNKNOWN_ATTRIB_LOCATION=-1;class Command{constructor(e,r,t,n,a,i,s,c,u,o,f){this.gl=e,this.glProgram=r,this.glPrimitive=t,this.uniformDescrs=n,this.count=a,this.offset=i,this.vertexArrayAcc=s,this.framebufferAcc=c,this.depthDescr=u,this.stencilDescr=o,this.blendDescr=f,this.currVao=null,this.currFbo=null}static create(e,{vert:r,frag:t,uniforms:n={},data:a,framebuffer:i,primitive:s="triangles",count:c=0,offset:u=0,depth:o,stencil:f,blend:l}){const h=e instanceof Device?e.gl:e,R=createShader(h,h.VERTEX_SHADER,r),m=createShader(h,h.FRAGMENT_SHADER,t),p=createProgram(h,R,m);h.deleteShader(R),h.deleteShader(m);const E=Object.entries(n).map(([e,r])=>{const t=h.getUniformLocation(p,e);if(!t)throw new Error(`No location for uniform: ${e}`);return new UniformDescriptor(e,t,r)}),A=a?"function"==typeof a||a instanceof VertexArray?a:VertexArray.create(e,locate(h,p,a)):void 0,d=i?"function"==typeof i||i instanceof Framebuffer?i:Framebuffer.create(h,i):void 0,F=parseDepth(h,o),B=parseStencil(h,f),b=parseBlend(h,l);return new Command(h,p,mapGlPrimitive(h,s),E,c,u,A,d,F,B,b)}execute(e){const{gl:r,glProgram:t}=this;r.useProgram(t),this.beginDepth(),this.beginStencil(),this.beginBlend(),Array.isArray(e)?e.forEach((e,r)=>this.executeInner(e,r)):this.executeInner(e,0),this.unbindFbo(),this.unbindVao(),this.endBlend(),this.endStencil(),this.endDepth(),r.useProgram(null)}locate(e){return locate(this.gl,this.glProgram,e)}executeInner(e,r){const{gl:t,count:n,offset:a,vertexArrayAcc:i,framebufferAcc:s}=this;let c=t.drawingBufferWidth,u=t.drawingBufferHeight;const o=s&&access(e,r,s);o&&(this.bindFbo(o),c=o.width,u=o.height),t.viewport(0,0,c,u),this.updateUniforms(e,r);const f=i&&access(e,r,i);if(f){this.bindVao(f);const e=n?Math.min(n,f.count):f.count;f.hasElements?this.drawElements(e,a,f.instanceCount):this.drawArrays(e,a,f.instanceCount)}else this.drawArrays(n,a,0)}bindVao(e){e!==this.currVao&&(this.currVao=e,this.gl.bindVertexArray(e.glVertexArray))}unbindVao(){this.gl.bindVertexArray(null),this.currVao=null}bindFbo(e){const r=this.gl;e!==this.currFbo&&(this.currFbo=e,r.bindFramebuffer(r.FRAMEBUFFER,e.glFramebuffer),r.drawBuffers(e.glColorAttachments))}unbindFbo(){const e=this.gl;e.bindFramebuffer(e.FRAMEBUFFER,null),this.currFbo=null}beginDepth(){const{gl:e,depthDescr:r}=this;r&&(e.enable(e.DEPTH_TEST),e.depthFunc(r.func),e.depthMask(r.mask),e.depthRange(r.rangeStart,r.rangeEnd))}endDepth(){const{gl:e,depthDescr:r}=this;r&&e.disable(e.DEPTH_TEST)}beginStencil(){const{gl:e,stencilDescr:r}=this;if(r){const{fFunc:t,bFunc:n,fFuncRef:a,bfuncRef:i,fFuncMask:s,bFuncMask:c,fMask:u,bMask:o,fOpFail:f,bOpFail:l,fOpZFail:h,bOpZFail:R,fOpZPass:m,bOpZPass:p}=r;e.enable(e.STENCIL_TEST),e.stencilFuncSeparate(e.FRONT,t,a,s),e.stencilFuncSeparate(e.BACK,n,i,c),e.stencilMaskSeparate(e.FRONT,u),e.stencilMaskSeparate(e.BACK,o),e.stencilOpSeparate(e.FRONT,f,h,m),e.stencilOpSeparate(e.BACK,l,R,p)}}endStencil(){const{gl:e,stencilDescr:r}=this;r&&e.disable(e.STENCIL_TEST)}beginBlend(){const{gl:e,blendDescr:r}=this;if(r&&(e.enable(e.BLEND),e.blendFuncSeparate(r.srcRGB,r.dstRGB,r.srcAlpha,r.dstAlpha),e.blendEquationSeparate(r.equationRGB,r.equationAlpha),r.color)){const[t,n,a,i]=r.color;e.blendColor(t,n,a,i)}}endBlend(){const{gl:e,blendDescr:r}=this;r&&e.disable(e.BLEND)}drawArrays(e,r,t){const{gl:n,glPrimitive:a}=this;t?n.drawArraysInstanced(a,r,e,t):n.drawArrays(a,r,e)}drawElements(e,r,t){const{gl:n,glPrimitive:a}=this;t?n.drawElementsInstanced(a,e,n.UNSIGNED_INT,r,t):n.drawElements(a,e,n.UNSIGNED_INT,r)}updateUniforms(e,r){const t=this.gl;let n=0;this.uniformDescrs.forEach(({identifier:a,location:i,definition:s})=>{switch(s.type){case"1f":t.uniform1f(i,access(e,r,s.value));break;case"1fv":t.uniform1fv(i,access(e,r,s.value));break;case"1i":t.uniform1i(i,access(e,r,s.value));break;case"1iv":t.uniform1iv(i,access(e,r,s.value));break;case"1ui":t.uniform1ui(i,access(e,r,s.value));break;case"1uiv":t.uniform1uiv(i,access(e,r,s.value));break;case"2f":{const[n,a]=access(e,r,s.value);t.uniform2f(i,n,a);break}case"2fv":t.uniform2fv(i,access(e,r,s.value));break;case"2i":{const[n,a]=access(e,r,s.value);t.uniform2i(i,n,a);break}case"2iv":t.uniform2iv(i,access(e,r,s.value));break;case"2ui":{const[n,a]=access(e,r,s.value);t.uniform2ui(i,n,a);break}case"2uiv":t.uniform2uiv(i,access(e,r,s.value));break;case"3f":{const[n,a,c]=access(e,r,s.value);t.uniform3f(i,n,a,c);break}case"3fv":t.uniform3fv(i,access(e,r,s.value));break;case"3i":{const[n,a,c]=access(e,r,s.value);t.uniform3i(i,n,a,c);break}case"3iv":t.uniform3iv(i,access(e,r,s.value));break;case"3ui":{const[n,a,c]=access(e,r,s.value);t.uniform3ui(i,n,a,c);break}case"3uiv":t.uniform3uiv(i,access(e,r,s.value));break;case"4f":{const[n,a,c,u]=access(e,r,s.value);t.uniform4f(i,n,a,c,u);break}case"4fv":t.uniform4fv(i,access(e,r,s.value));break;case"4i":{const[n,a,c,u]=access(e,r,s.value);t.uniform4i(i,n,a,c,u);break}case"4iv":t.uniform4iv(i,access(e,r,s.value));break;case"4ui":{const[n,a,c,u]=access(e,r,s.value);t.uniform4ui(i,n,a,c,u);break}case"4uiv":t.uniform4uiv(i,access(e,r,s.value));break;case"matrix2fv":t.uniformMatrix2fv(i,!1,access(e,r,s.value));break;case"matrix3fv":t.uniformMatrix3fv(i,!1,access(e,r,s.value));break;case"matrix4fv":t.uniformMatrix4fv(i,!1,access(e,r,s.value));break;case"texture":const c=access(e,r,s.value),u=n++;t.activeTexture(t.TEXTURE0+u),t.bindTexture(t.TEXTURE_2D,c.glTexture),t.uniform1i(i,u);break;default:never(s,`Unknown uniform type: (${a})`)}})}}class DepthDescriptor{constructor(e,r,t,n){this.func=e,this.mask=r,this.rangeStart=t,this.rangeEnd=n}}class StencilDescriptor{constructor(e,r,t,n,a,i,s,c,u,o,f,l,h,R){this.fFunc=e,this.bFunc=r,this.fFuncRef=t,this.bfuncRef=n,this.fFuncMask=a,this.bFuncMask=i,this.fMask=s,this.bMask=c,this.fOpFail=u,this.bOpFail=o,this.fOpZFail=f,this.bOpZFail=l,this.fOpZPass=h,this.bOpZPass=R}}class BlendDescriptor{constructor(e,r,t,n,a,i,s){this.srcRGB=e,this.srcAlpha=r,this.dstRGB=t,this.dstAlpha=n,this.equationRGB=a,this.equationAlpha=i,this.color=s}}class UniformDescriptor{constructor(e,r,t){this.identifier=e,this.location=r,this.definition=t}}class Texture{static fromImage(e,r,t){return Texture.fromRGBA8(e,r.data,r.width,r.height,t)}static fromRGBA8(e,r,t,n,a){return Texture.fromArrayBufferView(e,!r||r instanceof Uint8Array?r:new Uint8Array(r),t,n,"RGBA8","RGBA","unsigned byte",a)}static fromRG16F(e,r,t,n,a){return Texture.fromArrayBufferView(e,!r||r instanceof Float32Array?r:new Float32Array(r),t,n,"RG16F","RG","float",a)}static fromRGB16F(e,r,t,n,a){return Texture.fromArrayBufferView(e,!r||r instanceof Float32Array?r:new Float32Array(r),t,n,"RGB16F","RGB","float",a)}static fromRGBA16F(e,r,t,n,a){return Texture.fromArrayBufferView(e,!r||r instanceof Float32Array?r:new Float32Array(r),t,n,"RGBA16F","RGBA","float",a)}static fromRGB32F(e,r,t,n,a){return Texture.fromArrayBufferView(e,!r||r instanceof Float32Array?r:new Float32Array(r),t,n,"RGB32F","RGB","float",a)}static fromRGBA32F(e,r,t,n,a){return Texture.fromArrayBufferView(e,!r||r instanceof Float32Array?r:new Float32Array(r),t,n,"RGBA32F","RGBA","float",a)}static fromArrayBufferView(e,r,t,n,a,i,s,{min:c="nearest",mag:u="nearest",wrapS:o="clamp-to-edge",wrapT:f="clamp-to-edge",mipmap:l=!1}={}){const h=e instanceof Device?e.gl:e;return new Texture(h,r,t,n,a,i,s,o,f,c,u,l)}constructor(e,r,t,n,a,i,s,c,u,o,f,l){this.gl=e,this.data=r,this.width=t,this.height=n,this.internalFormat=a,this.format=i,this.type=s,this.wrapS=c,this.wrapT=u,this.minFilter=o,this.magFilter=f,this.mipmap=l,this.glInternalFormat=mapGlTextureInternalFormat(e,a),this.glFormat=mapGlTextureFormat(e,i),this.glType=mapGlTextureType(e,s),this.glWrapS=mapGlTextureWrap(e,c),this.glWrapT=mapGlTextureWrap(e,u),this.glMinFilter=mapGlTextureFilter(e,o),this.glMagFilter=mapGlTextureFilter(e,f),this.glTexture=null,this.init()}init(){const{gl:e,data:r,width:t,height:n,glInternalFormat:a,glFormat:i,glType:s,glWrapS:c,glWrapT:u,glMinFilter:o,glMagFilter:f,mipmap:l}=this,h=e.createTexture();e.bindTexture(e.TEXTURE_2D,h),e.texStorage2D(e.TEXTURE_2D,1,a,t,n),r&&e.texSubImage2D(e.TEXTURE_2D,0,0,0,t,n,i,s,r),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,c),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,u),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,o),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,f),l&&e.generateMipmap(e.TEXTURE_2D),e.bindTexture(e.TEXTURE_2D,null),this.glTexture=h}restore(){const{gl:e,glTexture:r}=this;e.isTexture(r)||this.init()}}export{Device,Command,VertexBuffer,ElementBuffer,VertexArray,Texture,Framebuffer};
//# sourceMappingURL=glutenfree.es.min.js.map
